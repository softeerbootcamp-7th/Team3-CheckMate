# 로그인 인증 개발 히스토리

> 참여자: 이영재, 정한울

## 현재 로직

1. `window.location.href = ${서버도메인}/auth/google?redirect_url={현재 사이트 도메인}`

   → fetch GET 메서드 사용 시 서버에서 구글 로그인 페이지로 redirect시키는 것 때문에 브라우저 CORS에 막혀서 `window.location.href`를 사용해서 브라우저에서 서버로 요청 후 구글 로그인 페이지로 redirect

2. 이후 구글 로그인
3. 구글 로그인 이후 → 서버에서 `{`/auth/google에서 보냈던 redirect_url`}/sign-in?state={}&code={}`으로 redirect시킴
4. `signInLoader` 에서 `state`, `code` ← oauth 2.0 토큰(구글에서 발급함) search param을 받아서 `/auth/google/callback` JWT 토큰 발급 api 호츨 ⇒ 로그인 성공 시 서버에서 쿠키에 refresh_token과 access token은 body로 리턴
5. 로그인 성

## 필요한 부분

- [ ] 로그인한 유저의 현재 정보를 알 수 있는 API 필요
  - 로그인 이후 해당 유저가 매장 등록을 안했는지
  - 매장 등록을 했지만 포스 연동을 안했는지
  - 포스 연동까지 완료했는지를 알아야 함

→ `/auth/me` 와 같이 유저 정보를 알아야 함

## 위 내역을 반영한 설계한 로그인 및 성공 이후 로직

```mermaid
sequenceDiagram
    autonumber
    actor User as 사용자
    participant Browser as 브라우저 (Client)
    participant Google as 구글 (OAuth)
    participant Server as 백엔드 서버
    participant DB as 데이터베이스

    User->>Browser: 구글 로그인 버튼 클릭
    Browser->>Google: 인증 요청
    Google-->>User: 로그인 및 동의 화면
    User->>Google: 로그인 완료
    Google-->>Browser: 리다이렉트 (code, state 포함)

    Note over Browser: signInLoader 실행

    Browser->>Server: POST /auth/google (code, state)
    Server->>Google: 토큰 교환 및 사용자 정보 획득
    Server->>DB: 사용자 확인 및 가입 처리
    Server-->>Browser: HTTP Only 쿠키 (Session/JWT) 설정 완료

    Note over Browser: 온보딩 상태 확인 시작

    Browser->>Server: GET /auth/me (사용자 정보 조회)
    Server->>DB: 사용자 온보딩 단계 조회
    DB-->>Server: status: "NONE" | "REGISTERED_STORE" | "COMPLETED"
    Server-->>Browser: { onboardingStatus: "..." }

    alt onboardingStatus === "NONE"
        Browser->>User: /onboarding/store-register 이동 (매장 등록 페이지)
    else onboardingStatus === "REGISTERED_STORE"
        Browser->>User: /onboarding/pos-connect 이동 (포스 연동 페이지)
    else onboardingStatus === "COMPLETED"
        Browser->>User: /dashboard 이동 (메인 대시보드)
    end
```

## TODO

- [x] 리프레쉬 날리는 경우. 디테일하게 뽑기\

@이영재

- [x] 매장 등록에 성공했을 경우 `POST /auth/refresh` 요청 보내기
  - 처음 로그인 했을 때 액세스 토큰 페이로드에 매장 ID가 존재하지 않음
  - 매장 등록에 성공했을 때 기존의 액세스 토큰을 들고 있으면 매장이 없는 것으로 처리됨
  - 액세스 토큰 재발급 필요
- loader 수정하기

```tsx
import { redirect } from 'react-router-dom';

import type { QueryClient } from '@tanstack/react-query';

import { getAuthGoogle } from '@/services/auth';
import { authOptions } from '@/services/auth/options';
import { authToken } from '@/services/shared';

export const signInLoader = (queryClient: QueryClient) => async () => {
  const searchParams = new URLSearchParams(window.location.search);

  // google 로그인 이후 redirect_url의 query params 에서 code 와 state 를 추출
  const code = searchParams.get('code');

  // code 와 state 가 없으면 로그인 페이지로 바로 이동
  if (!code) {
    return;
  }

  // query params 초기화 (새로고침 없이 지우기 위해 replaceState 사용)
  history.replaceState({}, document.title, window.location.pathname);

  // google oauth토큰으로 jwt 토큰 발급
  await getAuthGoogle({
    code,
    redirectUrl: `${window.location.origin}/sign-in`,
  }).then(({ accessToken }) => {
    authToken.set(accessToken);
  });

  // 현재 유저 상태에 따라 redirect
  const { onboaradingStatus } = await queryClient.ensureQueryData(
    authOptions.me,
  );

  switch (onboaradingStatus) {
    case 'NONE':
      throw redirect('/onboarding/store');
    case 'REGISTERED_STORE':
      throw redirect('/onboarding/pos');
    case 'COMPLETED':
      throw redirect('/dashboard');
  }
};
```

## 최종 형태

rontend에서 라우트에 연결된 loader는 아래 4개로 구성

- signInLoader.ts
  - 코드

```tsx
import { redirect } from 'react-router-dom';

import type { QueryClient } from '@tanstack/react-query';

import { getAuthGoogle } from '@/services/auth';
import { authOptions } from '@/services/auth/options';
import { authToken } from '@/services/shared';

const getUserAuthStatus = async (queryClient: QueryClient) => {
  const data = await queryClient
    .ensureQueryData(authOptions.status)
    .catch(() => {
      return null;
    });

  if (!data) {
    return null;
  }

  if (data.hasPosIntegration) {
    return redirect('/dashboard');
  }

  if (data.hasStore) {
    return redirect('/onboarding/pos');
  }

  return redirect('/onboarding/store');
};

export const signInLoader = (queryClient: QueryClient) => async () => {
  const searchParams = new URLSearchParams(window.location.search);

  // google 로그인 이후 redirect_url의 query params 에서 code 와 state 를 추출
  const code = searchParams.get('code');

  // code 와 state 가 없으면 로그인 페이지로 바로 이동
  if (!code) {
    return await getUserAuthStatus(queryClient);
  }

  // query params 초기화 (새로고침 없이 지우기 위해 replaceState 사용)
  history.replaceState({}, document.title, window.location.pathname);

  // google oauth토큰으로 jwt 토큰 발급
  await getAuthGoogle({
    code,
    redirectUrl: `${window.location.origin}/sign-in`,
  }).then(({ accessToken }) => {
    authToken.set(accessToken);
  });

  return await getUserAuthStatus(queryClient);
};
```

- main-page-loader.ts
- onBoardingStoreLoader.ts
- onBoardingPosLoader.ts

라우트 연결 위치:

- AuthRoutes.tsx → signInLoader
- MainPageRoutes.tsx → mainPageLoader
- OnboardingRoutes.tsx → onBoardingStoreLoader, onBoardingPosLoader

## 전체 인증 플로우

```mermaid
flowchart TD
  A["사용자가 앱 진입"] --> B["라우트별 loader 실행"]

  B --> C["/sign-in<br/>signInLoader"]
  B --> D["/ (main)<br/>mainPageLoader"]
  B --> E["/onboarding/store<br/>onBoardingStoreLoader"]
  B --> F["/onboarding/pos<br/>onBoardingPosLoader"]

  C --> C1{"URL에 code가 있는가?"}
  C1 -->|예| C2["Google 콜백 API 호출<br/>/auth/google/callback"]
  C2 --> C3["발급된 accessToken 저장"]
  C1 -->|아니오| C4["토큰 발급 없이 상태 확인으로 진행"]

  C3 --> G["auth/status 조회<br/>ensureQueryData(authOptions.status)"]
  C4 --> G
  D --> G
  E --> G
  F --> G

  G --> H{"인증 상태 조회 성공?"}
  H -->|아니오| I["/sign-in으로 리다이렉트<br/>미인증 또는 오류"]
  H -->|예| J{"hasPosIntegration ?"}
  J -->|예| K["/dashboard로 리다이렉트<br/>POS 연동 완료 사용자"]
  J -->|아니오| L{"hasStore ?"}
  L -->|예| M["/onboarding/pos로 리다이렉트<br/>매장 등록은 완료, POS 연동 필요"]
  L -->|아니오| N["/onboarding/store로 리다이렉트<br/>매장 등록부터 진행 필요"]

  D --> D1["mainPageLoader 분기 요약:<br/>POS 연동 완료 사용자만 메인 영역 접근 허용"]
  E --> E1["onBoardingStoreLoader 분기 요약:<br/>매장/POS 모두 미완료인 사용자만 접근 허용"]
  F --> F1["onBoardingPosLoader 분기 요약:<br/>매장 등록 완료 + POS 미연동 사용자만 접근 허용"]
```

## 참고 사이트

- [https://hochi-dev.tistory.com/8](https://hochi-dev.tistory.com/8)
- [https://medium.com/@sina.alizadeh120/repeating-failed-requests-after-token-refresh-in-axios-interceptors-for-react-js-apps-50feb54ddcbc](https://medium.com/@sina.alizadeh120/repeating-failed-requests-after-token-refresh-in-axios-interceptors-for-react-js-apps-50feb54ddcbc)
