# cf) 로그아웃 시 모든 쿼리 remove

# 태그 정의

### 1) `[NO_CACHE]`

**:** 자주 변동되고 이전 캐싱 값이 사용자에게 오히려 혼란을 주는 데이터

옵션 **설정:** `staleTime: 0` 

cf) gcTime 0으로 설정하지 않은 이유 

: gcTime 0으로 설정하면 화면에 보여줄 임시값(stale상태 캐시값)이 생성과 즉시 없어지기 때문에 사용자는 매번 로딩 화면 보게 됨. 상세분석 페이지 전환 시 마다 매번 로딩 화면 보여주면 더 번잡한 UI. 기본 gfTime은 유지해서 페이지 빠르게 변경할 때는 이전 캐싱된 데이터값 보여지게

### 2) `[MUTABLE]`

: 수정 가능(POST/PATCH/DELETE) + **다른 기기로 접속해 변경하면 현재 화면에도 반영**되어야 하는 데이터

: 단 자주 변경되는 데이터 아님

옵션 **설정:** `staleTime: 15`, 변경 성공 시 `invalidate / setQueryData`로 변경사항 캐시에 알림 

특이점 : 변경이 발생하면 queryClient.setQueryData()로 캐시값 바로 업데이트

### 3) `[IMMUTABLE]`

: 변하지 않는 데이터 = GET 호출만 가능한 데이터

→ 다시 받을 필요 없다

옵션 **설정:** `staleTime: Infinity`, `gcTime: Infinity`

### 4) `[EVENT_UPDATED]`

: 고정 데이터인데 **특정 이벤트(SSE/하루 1회 등)** 때만 바뀜 → 그때 invalidate

옵션 **설정:** `staleTime: Infinity`, `gcTime: Infinity`, 이벤트 발생 시 `invalidateQuery`

```jsx
export const QUERY_CACHE = {
  NO_CACHE: {
    staleTime: 0,
  },
  MUTABLE: {
    //수정 가능(POST/PATCH/DELETE) + 다른 컴퓨터에서 변경하면 현재 화면에도 반영되어야 하는 데이터
    // 단 변경이 자주 발생하지 않음
    staleTime: 15 * MIN,
    gcTime: 1 * HOUR, // 한번 닫으면 다시 확인하기 까지 오래 걸리는 데이터. 오래 메모리에 들고 있을 필요 없음
  },

  IMMUTABLE: {
    // 변하지 않는 데이터 -> 영구적으로 캐싱.(물론 새로고침 시 날라감)
    staleTime: Infinity,
    gcTime: Infinity,
  },
} as const;

```

---

# 대시보드 페이지

### 대시보드 레이아웃 데이터: [MUTABLE]

: 각 대시보드 내의 카드 정보 및 레이아웃 정보

### 대시보드 목록 데이터: [MUTABLE]

### 대시보드 지표 데이터 : [NO_CACHE]

: 주문 발생에 따라 실시간으로 계속 업데이트 되어야 하는 데이터로 이전 캐싱 데이터가 오히려 사용자에게 

탄스택 쿼리를 사용하는 목적이 이전 결과 재사용(캐싱)이 목적이 아니라 상태 저장소 목적으로 사용

# 상세분석 페이지

### 카드별 상세 분석 데이터 [NO_CACHE]

# 하루 리포트 페이지

### 다음 매장 마감 시간 : [MUTABLE]

: 요일이 바뀌면 다음 매장 마감 시간도 바뀜

### 미열람 상태 리포트 데이터 : [MUTABLE]

- 사용자가 읽지 않은 리포트 있는지 여부
- ⭐️ 이 데이터는 gcTime 0 으로 설정.
- stale 상태 데이터 재활용 하는 탄스택 쿼리특성때문에 잘못된 정보를 줬을 때 혼란이 큰 데이터(알림x -> 알림 O / 알림 O -> 알림 X)

### 알림 목록 데이터[MUTABLE]

- 사용자가 전체 삭제 누르면 바뀌는 데이터

### 캘린더의 월별 매출 데이터 : [EVENT_UPDATE]

- 이번달 매출 정보의 경우 하루 리포트 발행되면 변경되어야 함(오늘 매출 정보가 추가되기 때문)

### 하루 리포트 데이터 : [IMMUTABLE]

- 한번 발행된 리포트는 내용이 변경되지 않음

---

### ⭐️하루리포트 관련 메모리 최적화

`하루 리포트` 데이터와 `캘린더의 월별 매출` 데이터는 바뀌지 않는 데이터여서 gcTime:infinity로 설정함. 

하지만 이 **두 데이터는 사용자 작동에 따라 무한개 쌓일 수 있는 데이터**

(ex: 모든 하루 리포트 열람 or 달력 무한 이동)

→ 다른 IMMUTABLE 데이터와 다르게 생성되는 양에 제한이 없음

### 데이터 개수 확인

하루리포트 데이터와 캘린더 월별 매출 데이터는 사용자가 ‘하루리포트’ 페이지를 닫을 때 쌓인 데이터 개수를 확인

- 하루 리포트 페이지 관련 전체 캐시 데이터가 특정 개수(ex: 30) 이상이면
    
    : 이번달 매출 데이터/ 오늘 하루 리포트 캐시만 남기고 모두 remove()
    
- 코드
    
    ```jsx
    import { useEffect } from 'react';
    
    import { useQueryClient } from '@tanstack/react-query';
    
    import { dailyReportKeys } from '@/services/daily-report';
    import { formatDateISO } from '@/utils/shared';
    
    // 페이지 닫을 때 하루 리포트 관련 캐시 너무 많이 쌓여 있다면 오늘 데이터 제외하고 다 제거하는 훅
    
    const DAILY_REPORT_CACHE_LIMIT = 20; // 하루 리포트 관련 캐시(데일리 리포트, 월별 매출 정보)가 10개 이상이면 초기화
    
    export const useClearDailyReportAndCalenderCache = () => {
      const queryClient = useQueryClient();
    
      useEffect(() => {
        return () => {
          // 하루 리포트 관련 캐시 개수
          const dailyReportQueriesCount = queryClient
            .getQueryCache()
            .findAll({ queryKey: dailyReportKeys.all }).length;
    
          if (dailyReportQueriesCount <= DAILY_REPORT_CACHE_LIMIT) {
            return; // 캐시 개수가 20개 이하라면 초기화 안 함
          }
          // 오늘에 해당하는 데일리 리포트 캐시 데이터 미리 저장
          const today = new Date();
          const todayDailyReportChche = queryClient.getQueryData(
            dailyReportKeys.content(formatDateISO(today) ?? ''),
          );
          const thisMonthCalenderCache = queryClient.getQueryData(
            dailyReportKeys.calendar(today.getFullYear(), today.getMonth() + 1),
          );
    
          // 하루 리포트 관련 캐시 모두 제거
          queryClient.removeQueries({
            queryKey: dailyReportKeys.all,
          });
    
          // 오늘에 해당하는 데일리 리포트 캐시 데이터 다시 저장
          if (todayDailyReportChche) {
            queryClient.setQueryData(
              dailyReportKeys.content(formatDateISO(today) ?? ''),
              todayDailyReportChche,
            );
          }
          // 이번달에 해당하는 데일리 리포트 캐시 데이터 다시 저장
          if (thisMonthCalenderCache) {
            queryClient.setQueryData(
              dailyReportKeys.calendar(today.getFullYear(), today.getMonth() + 1),
              thisMonthCalenderCache,
            );
          }
        };
      }, [queryClient]);
    };
    
    ```
    

---

### 프리패칭 전략

- 알림 버튼에 마우스 hover 시 알림 목록 데이터 프리패칭
- 하루리포트 페이지 진입 시 이번 달 리포트 중 오늘 제외 가장 최신 리포트 프리페치
    
    ![스크린샷 2026-02-23 오후 5.50.38.png](attachment:2627943c-3425-4634-ac82-7e6ef41f6894:스크린샷_2026-02-23_오후_5.50.38.png)
    
    다음과 같은 상황에서는 2/20일 리포트 프리 패칭
    

# 환경설정 페이지

### 메장 정보 : [IMMUTABLE]

- 바뀌지 않는 데이터

### 전체 메뉴 정보:  [MUTABLE]

- 사용자가 메뉴 등록 시 변경되는 데이터
- 또한 식자재 존재 유무 데이터가 있어 식자재가 변경될 때(무↔유) 바뀌어야 함
- `invalidated`  시점: 식자재 정보 바뀔때,

### 메뉴의 식자재 정보: [MUTABLE]

- 사용자가 식자재 정보를 수정할 수 있고 수정된 반영 되어야 함
- 식자재 수정 시 전체메뉴 정보도 invalidate 시켜야함
    
    : 전체 메뉴 정보에 식자재 존재 유무 데이터가 있어 식자재가 변경될 때(무↔유) 바뀌어야 함 
    

## 프리패칭 전략

- 환경설정 페이지의 ‘식자재 관리 버튼’ 에 hover 시 메뉴 리스트 프리패치
    
    : 현재 환경설정 페이지에서 제공하는 주요 기능은 식재료 관리 뿐
    
    : 따라서 환경설정 페이지에 들어와서 식재료 관리 버튼 쪽으로 다가오면 식재료 관리 페이지 진입을 희망하고 있다고 판단
    
- cf) 메뉴 식자재 정보 프리패칭 하지 않은 이유
    
    : 초기에는 메뉴 카드에 마우스 hover시 해당 메뉴에 해당하는 식자재 목록을 프리패칭 했었는 데 그렇게 되면 카드 배열 화면에서 마우스 휘적이면 불필요한 데이터 prefetch 너무 많이 발생