## 1. 리포트 발행 워커(Worker) 상세 프로세스

워커는 Redis 큐를 기점으로 '작업 인출 - 분석 - 생성 - 완료'의 생명 주기를 가집니다. 각 단계는 시스템의 안정성과 데이터의 정합성을 보장하도록 설계되었습니다.

### 1단계: Reliable Fetch
- 메커니즘: `RPOPLPUSH` 연산을 사용하여 `WAITING_QUEUE`에서 작업을 꺼냄과 동시에 `PROCESSING_QUEUE`로 이동
- 효과: 워커가 데이터를 가져간 직후 크래시가 발생하더라도 작업 데이터가 유실되지 않고 처리 중 리스트에 남아 있어 추후 복구가 가능

### 2단계: Data Aggregation
- 대상: 매장의 Trend(추세), Level(체급), 실매출, 총매출 등
    - Trend(추세): 단계별로 전일, 전주, 혹은 최근 4주 동요일 데이터를 대조군으로 설정
    - Level(체급): 최근 7~28일간의 실적을 집계하여 매장의 평균적인 '기초 체력'을 산출
- 가공: 오늘 실적과의 변동률(Delta)을 계산하여 LLM이 즉시 인사이트를 도출할 수 있는 정형 데이터를 완성

### 3단계: LLM 요청
- 프롬프트: ‘하루 리포트 작성기' 페르소나를 부여하고, 결과값은 반드시 서비스에 바인딩 가능한 정형 JSON 구조로 응답하도록 강제
- 호출: 외부 API(Gemini)를 호출하며, 현재는 동기 방식으로 응답을 대기

### 4단계: Data Parsing
- 매핑: `ObjectMapper`를 사용해 LLM 응답을 `Report` 엔티티와 하위 Value Object(KPI, 인사이트 아이템 등)로 변환
- 검증: 필수 필드가 누락되었는지, 비정상적인 수치가 포함되었는지 확인하는 유효성 검사를 수행

### 5단계: 결과 저장 및 알림
- 저장: 최종 리포트 엔티티를 RDB에 저장
- 알림: Redis에 `notification:unread:{storeId}` 키를 생성하여 실시간성을 확보
- 정리: 모든 과정이 성공하면 `PROCESSING_QUEUE`에 남아있던 작업을 삭제하여 사이클을 종료

<br>

## 2. 기술적 제약 및 향후 고도화 과제

현재 파이프라인은 안정적인 리포트 발행이라는 목적에 설계되었습니다. 개발 일정상 현 단계에서 적용하지 못했으나, 시스템 확장 시 우선적으로 개선이 필요한 고도화 과제들을 정리했습니다.

### 2-1. 비동기 I/O 모델 최적화 (Virtual Threads)
- 현황: WebFlux 의존성 추가 부담과 디버깅 복잡성으로 인해 익숙한 동기 방식인 `RestClient` 채택
- 고도화: JDK 21의 가상 스레드(Virtual Threads)를 도입하여 동기식 코드의 가독성을 유지하면서 LLM 응답 대기 시의 스레드 점유 문제를 효율적으로 해결

### 2-2. 워커 스레드 튜닝 및 정밀 모니터링
- 현황: API 및 대시보드(SSE)와 자원을 공유 중이나, 실제 부하 상황에서의 임계치 테스트 미흡
- 고도화: 동시 접속자 및 주문 발생 시나리오를 바탕으로 남아있는 CPU/메모리 자원을 측정하여, API 성능에 영향을 주지 않는 최적의 워커 스레드 개수와 작업 주기 도출

### 2-3. Redis 파이프라이닝을 통한 벌크 적재
- 현황: 매장 리스트를 가져와 개별적으로 `leftPush`를 수행하고 있어 매장 수 증가 시 네트워크 RTT 오버헤드 발생 우려
- 고도화: **Redis Pipelining**을 도입하여 수천 개의 작업을 한 번에 적재하는 벌크 적재 방식으로 리팩토링함으로써 큐 적재 시간 단축

### 2-4. 외부 API 장애 탄력성 및 운영 자동화
- 현황: Gemini API 장애 시 단순 재시도 로직에 의존하고 있으며, 최종 실패 작업에 대한 수동 대응 체계 부재
- 고도화: **Circuit Breaker** 도입을 통해 장애 발생 시 타 LLM(GPT, Claude 등)으로의 폴백 전략 구축 및 n8n을 활용한 **DLQ(Dead Letter Queue) 슬랙 알림** 자동화로 운영 가용성 확보
