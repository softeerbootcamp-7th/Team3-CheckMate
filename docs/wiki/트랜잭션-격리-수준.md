# 트랜잭션 격리 수준

# 1. 개요

`MNU_05 (인기 메뉴 조합)`은 매장 데이터를 기반으로  
**인기 메뉴와 함께 가장 많이 주문된 메뉴 조합을 분석하는 비즈니스 로직**


---
# 2. 요구사항
1. **기준 기간 동안의 매출 기준 TOP3 메뉴 선정**
   - 매출 기준으로 계산
   - 판매 수량이 아닌 **매출 금액 기준**

2. 각 TOP3 메뉴에 대해  
   **함께 주문된 메뉴 중 주문 건수가 가장 많은 상위 5개 메뉴 추출**
   - 함께 선택된 메뉴는 **주문 건수 기준**
   - 매출 기준이 아님



  ### 정리

  | 구분 | 계산 기준 |
  |------|------------|
  | TOP3 기준 메뉴 | 매출 금액 기준 |
  | 함께 많이 선택된 메뉴 | 주문 건수 기준 |

---

# 3. 트랜잭션 격리 수준을 REPEATABLE READ로 설정한 이유

해당 로직에서는  주문 데이터를 기준으로 두 번 조회가 발생

```java
// 1. 매출 기준 TOP3 메뉴 조회
findTop3MenuIds(...);

// 2. 주문별 메뉴 리스트 조회
findOrderMenuBundles(...);
```

## 트랜잭션 격리 수준이 REPEATABLE READ보다 낮을 경우 발생할 수 있는 문제

트랜잭션이 없거나, 격리 수준이 **REPEATABLE READ보다 낮은 경우 (예: READ COMMITTED)**  
다음과 같은 문제가 발생할 수 있음

| 시점 | 동작 |
|------|------|
| T1 | 매출 기준 TOP3 메뉴 조회 |
| T2 | 새로운 주문 생성 또는 기존 주문 변경 |
| T3 | 주문별 메뉴 리스트 조회 |

이 경우,

- TOP3 메뉴는 **T1 시점 기준 데이터**
- 주문별 메뉴 리스트는 **T3 시점 기준 데이터**

를 기반으로 조회될 수 있음

즉, 하나의 비즈니스 로직 안에서 **기준 시점이 서로 다른 데이터**를 사용하게 되어 일관성이 깨질 수 있음



## 왜 이런 문제가 발생하는가?

이 문제를 이해하려면 먼저 **가시성(Visibility)** 과 **스냅샷(Snapshot)** 개념을 간단히 알아야 함



### 가시성이란?

PostgreSQL은 MVCC 기반으로 동작하기 때문에  
하나의 데이터(row, 튜플)는 동시에 여러 버전을 가질 수 있음

예를 들어,

- 변경 전 버전
- 변경 후 버전

이 동시에 존재할 수 있음

이때 트랜잭션은 여러 버전 중

> **어떤 버전을 읽을 것인지 결정해야 함**

이것을 결정하는 개념이 바로 **가시성(Visibility)** 임



### 스냅샷(Snapshot)이란?

스냅샷은

> 트랜잭션이 어떤 데이터 버전을 볼 수 있는지 결정하는 기준 정보


즉,

- 어떤 트랜잭션은 변경 전 데이터를 보고
- 어떤 트랜잭션은 변경 후 데이터를 볼 수 있음

이 차이를 만들어내는 기준이 스냅샷



## READ COMMITTED에서 문제가 발생하는 이유

PostgreSQL의 기본 격리 수준인 **READ COMMITTED**는

> 쿼리 시작 시점마다 스냅샷을 새로 생성

따라서 하나의 트랜잭션 안에서도

```
SELECT A  → snapshot1
SELECT B  → snapshot2
```

처럼 서로 다른 스냅샷을 사용할 수 있음

이 경우,

- 첫 번째 조회는 snapshot1 기준
- 두 번째 조회는 snapshot2 기준

으로 실행되며,  
두 조회 사이에 발생한 데이터 변경이 두 번째 조회에는 반영될 수 있음

그 결과, **하나의 비즈니스 로직** 안에서  
**기준 시점이 다른 데이터가 섞이는 문제**가 발생할 수 있음

---
> 스냅샷의 내부 구조(xmin, xmax, active tx list 등)와  
> MVCC의 상세 동작 원리는 뒤에서 자세히 설명
---

## REPEATABLE READ를 사용하면?

REPEATABLE READ는

- **트랜잭션 시작 시점에 단 한 번 스냅샷을 생성**
- 트랜잭션 종료까지 동일 스냅샷 유지

```
BEGIN
SELECT A  → snapshot1
SELECT B  → snapshot1
COMMIT
```

따라서 두 조회는 항상 **동일한 기준 시점의 데이터**를 사용하게 됨



### 정리

| 격리 수준 | 스냅샷 생성 시점 | 비즈니스 로직 일관성 |
|------------|------------------|------------------|
| READ COMMITTED | 쿼리마다 | 깨질 수 있음 |
| REPEATABLE READ | 트랜잭션 시작 시 | 보장됨 |

따라서 해당 비즈니스 로직에서는  
동일 기준 시점의 데이터 일관성을 보장하기 위해  
REPEATABLE READ를 사용함

---

# 4. PostgreSQL은 격리수준을 어떻게 보장하는가?

PostgreSQL에서는 모든 트랜잭션이 **고유한 트랜잭션 ID(Transaction ID, XID)** 를 가짐

이 트랜잭션 ID는

- 순차적으로 증가하는 값이며
- 데이터 변경의 발생 순서를 판단하는 기준이 됨




## PostgreSQL 튜플 구조

PostgreSQL에서 하나의 튜플은 다음 두 가지 트랜잭션 ID를 가짐

| 필드 | 의미 |
|------|------|
| xmin | 이 튜플을 생성한 트랜잭션 ID |
| xmax | 이 튜플을 삭제한 트랜잭션 ID |



##  스냅샷 구성 요소
스냅샷은 다음 3가지 정보를 가짐

| 구성 요소 | 의미 |
|------------|------|
| xmin | 스냅샷 시점에 활성화된 트랜잭션 중 가장 오래된 ID |
| xmax | 스냅샷 시점에 커밋된 트랜잭션 ID 중 최대값 + 1 |
| active tx list | 스냅샷 시점에 아직 활성 상태인 트랜잭션 ID 목록 |



## 튜플 가시성 판단 방식

트랜잭션이 튜플을 읽을 때, 튜플의 트랜잭션 ID와 자신의 스냅샷을 비교하여 읽을지 결정

### 1) 튜플의 변경 트랜잭션 ID < snapshot.xmin

- 이미 커밋 완료된 과거 트랜잭션
- 읽어도 됨

### 2) 튜플의 변경 트랜잭션 ID ≥ snapshot.xmax

- 스냅샷 시점에서 아직 커밋 여부가 확정되지 않은 트랜잭션
- 읽으면 안 됨

### 3) xmin ≤ 변경 트랜잭션 ID < xmax

- 활성 상태일 수도 있고, 커밋됐을 수도 있음
- snapshot의 active tx list를 확인

  - active list에 있다 → 아직 진행 중 → 보이면 안 됨
  - 없다 → 이미 커밋됨 → 보여도 됨

---

# 5. READ COMMITTED vs REPEATABLE READ

## READ COMMITTED (PostgreSQL 기본)

- 쿼리 시작 시점마다 스냅샷 생성
- SELECT를 여러 번 하면 매번 다른 스냅샷을 사용할 수 있음

예시:

```
SELECT A  → snapshot1
SELECT B  → snapshot2
```

두 SELECT의 기준 시점이 달라질 수 있음



## REPEATABLE READ

- 트랜잭션 시작 시점에 스냅샷 1번 생성
- 트랜잭션 종료까지 동일 스냅샷 사용

예시:

```
BEGIN
SELECT A  → snapshot1
SELECT B  → snapshot1
COMMIT
```

항상 동일한 가시성 보장

---

# 6. 결론

이 비즈니스 로직은

1. 매출 기준 TOP3 메뉴 계산
2. 주문별 메뉴 리스트 조회

을 수행하며, 모두 동일한 기준 시점의 데이터를 기반으로 해야 함

따라서 REPEATABLE READ를 사용하여  
트랜잭션 시작 시점의 동일한 스냅샷을 유지하도록 설계


# 참고
임경석 외. 막힘없이 PostgreSQL. 엑셈, 2025.
